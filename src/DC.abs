module ABS.DC;

export SimDeploymentComponent, CloudProvider, SimCloudProvider;

import * from ABS.SetsMaps;

class SimDeploymentComponent(String description, Map<Resourcetype,Rat> initconfig) implements DeploymentComponent {
  Int instrPS= truncate(lookupDefault(initconfig, Speed, 0));

  // TODO
  Rat load(Resourcetype rtype, Int periods) { 
    return 0; 
  }

  InfRat total(Resourcetype rtype) {
    return case lookup(initconfig, rtype) {
        Nothing => InfRat;
        Just(v) => Fin(v);
    };
   }

  Unit transfer(DeploymentComponent target, Rat amount, Resourcetype rtype) {}

  // TODO
  Unit decrementResources(Rat amount, Resourcetype rtype) {}
  // TODO
  Unit incrementResources(Rat amount, Resourcetype rtype) {}
  
  String getName() {
    return description;
  }

  // CloudProvider getProvider();

  // TODO
   Time getCreationTime() {
    return now(); // stub, TODO
  }
   Rat getStartupDuration() {
    return 0;
  }

  // TODO
   Rat getShutdownDuration() {
    return 0;
  }

  // TODO
   Int getPaymentInterval() {
    return 0;
  }

  // TODO
   Rat getCostPerInterval() {
    return 0;
  }

  // TODO
   Rat getNumberOfCores() {
    return 0;
  }
  // TODO
  Bool acquire() { return True; }
  // TODO
  Bool release() { return True; }
  // TODO
  Bool shutdown() { return True; }

  Unit request__(Int nrInstr) {
    if (nrInstr > instrPS) {
      duration(1,1);
      suspend;
      return this.request__(nrInstr-instrPS); // tail-recursive
    }
    else {
      Rat remaining = nrInstr/instrPS;
      duration(remaining,remaining);
    }
  }
}


// interface DeploymentComponentForCloudProvider extends DeploymentComponent {
//     Unit setProvider(CloudProviderForDeploymentComponent provider);
// }

interface CloudProvider {
    // (pre)launchInstance might have a delay, the others are instantaneous.
    // launchInstance might hand out an already-running instance if it has
    // been released; in this case there will be no delay.
    DeploymentComponent prelaunchInstance(Map<Resourcetype, Rat> d);
    DeploymentComponent launchInstance(Map<Resourcetype, Rat> description);
    // acquireInstance, releaseInstance are called from deployment components.
    // launchInstance does the equivalent of acquireInstance.
    Bool acquireInstance(DeploymentComponent instance_);
    //Bool releaseInstance(DeploymentComponent instance_);
    Bool shutdownInstance(DeploymentComponent instance_);

    // Rat getAccumulatedCost();
    //Unit shutdown();

    // Instance descriptions.  Call setInstanceDescriptions with a map of
    // (name -> resources) information.  Then, launchInstanceNamed() returns a
    // deployment component with the specified resources, or null if the given
    // name could not be found.  The resulting deployment components are then
    // handled as normal (acquire/release/kill).
    Unit setInstanceDescriptions(Map<String, Map<Resourcetype, Rat>> instanceDescriptions);
    Unit addInstanceDescription(Pair<String, Map<Resourcetype, Rat>> instanceDescription);
    Unit removeInstanceDescription(String instanceDescriptionName);
    Map<String, Map<Resourcetype, Rat>> getInstanceDescriptions();
    DeploymentComponent prelaunchInstanceNamed(String instancename);
    DeploymentComponent launchInstanceNamed(String instancename);

    Unit addSmartDeployInstances();
}

// interface CloudProviderForDeploymentComponent extends CloudProvider {
//     Unit internalShutdownInstance(DeploymentComponentForCloudProvider instance_);
// }


class SimCloudProvider(String name) implements CloudProvider {
    // Preliminary version - mind the FIXMEs!

    // Instance type descriptions for launchInstanceNamed()
    Map<String, Map<Resourcetype, Rat>> instanceDescriptions = map[];

    // All launched instances
    // Set<DeploymentComponent> launchedInstances = set[];
    // // Launched instances that are currently acquired
    // Set<DeploymentComponent> acquiredInstances = set[];
    // Set<DeploymentComponent> killedInstances = set[];

    List<DeploymentComponent> launchedInstances = list[];
    // Launched instances that are currently acquired
    List<DeploymentComponent> acquiredInstances = list[];
    List<DeploymentComponent> killedInstances = list[];

    Int nextInstanceId = 0;
    // Rat accumulatedCost = 0;
    Bool keeprunning = True;    // Flag for forced shutdown

    // Unit startAccounting() {
    //     while(keeprunning && !emptySet(launchedInstances)) {
    //         Rat cost = this.sumOfCosts(launchedInstances);
    //         accumulatedCost = accumulatedCost + cost;
    //         await duration(1, 1);
    //     }
    // }

    //Unit shutdown() { keeprunning = False; }

    // Rat sumOfCosts(Set<DeploymentComponent> dcs_) {
    //     Set<DeploymentComponent> dcs = dcs_;
    //     Rat result = 0;
    //     Time t = now();
    //     while (!emptySet(dcs)) {
    //         DeploymentComponent dc = take(dcs);
    //         dcs = remove(dcs, dc);
    //         Rat cost = await dc!getCostPerInterval();
    //         if (cost > 0) {
    //             Time creationtime = await dc!getCreationTime();
    //             Rat time_elapse = timeDifference(t, creationtime);
    //             Int interval = await dc!getPaymentInterval();
    //             if (time_elapse % interval == 0) {
    //                 result = result + cost;
    //             }
    //         }
    //     }
    //     return result;
    // }

    DeploymentComponent createInstance(String instancename, Map<Resourcetype, Rat> d) {
        //Bool mightNeedToStartAccounting = emptySet(launchedInstances);
        // DeploymentComponentForCloudProvider result
        // = new SimDeploymentComponent(instancename + "-" + toString(nextInstanceId), d);
        DeploymentComponent result = new SimDeploymentComponent(instancename + "-" + toString(nextInstanceId), d);
        //result!setProvider(this);
        nextInstanceId = nextInstanceId + 1;
        // Work around a bug in the type system: upcasting in `insertElement'
        // does not work although it should
        DeploymentComponent stupidTypeSystem = result;
        //launchedInstances = insertElement(launchedInstances, stupidTypeSystem);
        launchedInstances = Cons(stupidTypeSystem,launchedInstances);
        // Start accounting after adding new machine, before waiting for it to
        // start up
        //if (mightNeedToStartAccounting) this!startAccounting();
        return result;
    }

    DeploymentComponent prelaunchInstance(Map<Resourcetype, Rat> d) {
        DeploymentComponent result = this.createInstance(name, d);
        Rat startup_duration = await result!getStartupDuration();
        await duration(startup_duration, startup_duration);
        return result;
    }

    DeploymentComponent prelaunchInstanceNamed(String instancename) {
        Maybe<Map<Resourcetype, Rat>> mconfig = lookup(instanceDescriptions, instancename);
        DeploymentComponent dc = null;
        if (isJust(mconfig)) {
            Map<Resourcetype, Rat> config = fromJust(mconfig);
            dc = this.createInstance(name + "-" + instancename, config);
        }
        Rat startup_duration = await dc!getStartupDuration();
        await duration(startup_duration, startup_duration);
        return dc;
    }

    DeploymentComponent launchInstance(Map<Resourcetype, Rat> d) {
        // if we don't call prelaunchInstance here, remember to start
        // accounting as well
        DeploymentComponent result = this.prelaunchInstance(d);
        //acquiredInstances = insertElement(acquiredInstances, result);
        acquiredInstances = Cons(result,acquiredInstances);
        return result;
    }

    DeploymentComponent launchInstanceNamed(String instancename) {
        // if we don't call prelaunchInstance here, remember to start
        // accounting as well
        DeploymentComponent result = this.prelaunchInstanceNamed(instancename);
        if (result != null) {
            //acquiredInstances = insertElement(acquiredInstances, result);
            acquiredInstances = Cons(result,acquiredInstances);
        }
        return result;
    }

    Bool acquireInstance(DeploymentComponent instance_) {
        Bool result = True;
        //CloudProvider cp = await instance_!getProvider();
        // if (cp != this) {
        //     // it's not one of "our" deployment components
        //     result = False;
        // } else 
        if (contains_(acquiredInstances, instance_)
            || contains_(killedInstances, instance_)) {
            result = False;
        } else {
            //acquiredInstances = insertElement(acquiredInstances, instance_);
          acquiredInstances = Cons(instance_, acquiredInstances);
        }
        return result;
    }
    // Bool releaseInstance(DeploymentComponent instance_) {
    //     // FIXME: Currently we do not protect against double-release and always
    //     // return True.  Once we have means of testing whether there is still
    //     // activity on a deployment component, we could refuse to release it in
    //     // that case and return False.
    //     if (contains(acquiredInstances, instance_)) {
    //         acquiredInstances = remove(acquiredInstances, instance_);
    //     }
    //     return True;
    // }

    Bool shutdownInstance(DeploymentComponent instance_) {
        instance_!shutdown();
        return True;
    }

    // Unit internalShutdownInstance(DeploymentComponentForCloudProvider instance_) {
    //     DeploymentComponent stupidTypeSystem = instance_;
    //     // Also kill an instance that is acquired.  FIXME: is this the right
    //     // thing, or should we refuse to shutdown?
    //     acquiredInstances = remove(acquiredInstances, stupidTypeSystem);
    //     // Insert `instance' into killedInstances so it doesn't get
    //     // re-acquired.
    //     killedInstances = insertElement(killedInstances, stupidTypeSystem);
    //     Rat shutdown_duration = await instance_!getShutdownDuration();
    //     await duration(shutdown_duration, shutdown_duration);

    //     // Now remove from launchedInstances (after waiting for shutdown) so
    //     // shutdown duration gets billed
    //     launchedInstances = remove(launchedInstances, stupidTypeSystem);

    //     // Shut down accounting thread if necessary
    //     if (emptySet(launchedInstances)) keeprunning = False;
    // }

    // Rat getAccumulatedCost() {
    //     return accumulatedCost;
    // }

    // Sets up information for [pre]launchInstanceNamed()
    Unit setInstanceDescriptions(Map<String, Map<Resourcetype, Rat>> instanceDescriptions) {
        this.instanceDescriptions = instanceDescriptions;
    }

    // Adds an instance for [pre]launchInstanceNamed()
    Unit addInstanceDescription(Pair<String, Map<Resourcetype, Rat>> instanceDescription) {
        this.instanceDescriptions = insert(this.instanceDescriptions, instanceDescription);
    }

    // Removes an instance for [pre]launchInstanceNamed() based on its name
    Unit removeInstanceDescription(String instanceDescriptionName) {
        this.instanceDescriptions = removeKey(this.instanceDescriptions, instanceDescriptionName);
    }

    Map<String, Map<Resourcetype, Rat>> getInstanceDescriptions() {
        return this.instanceDescriptions;
    }
    Unit addSmartDeployInstances(){
    this.addInstanceDescription(Pair( "c4_2xlarge_eu", map(Cons( Pair( CostPerInterval, 419 ), Cons( Pair( Cores, 8 ), Cons( Pair( Memory, 1500 ), Cons( Pair( Speed, 31 ), Nil ) ) ) )) ));
    this.addInstanceDescription(Pair( "m4_large_eu", map(Cons( Pair( CostPerInterval, 120 ), Cons( Pair( Cores, 2 ), Cons( Pair( Memory, 800 ), Cons( Pair( Speed, 6 ), Nil ) ) ) )) ));
    this.addInstanceDescription(Pair( "m4_xlarge_eu", map(Cons( Pair( CostPerInterval, 239 ), Cons( Pair( Cores, 4 ), Cons( Pair( Memory, 1600 ), Cons( Pair( Speed, 13 ), Nil ) ) ) )) ));
    this.addInstanceDescription(Pair( "m4_large_us2", map(Cons( Pair( CostPerInterval, 120 ), Cons( Pair( Cores, 2 ), Cons( Pair( Memory, 800 ), Cons( Pair( Speed, 6 ), Nil ) ) ) )) ));
    this.addInstanceDescription(Pair( "c4_2xlarge_us1", map(Cons( Pair( CostPerInterval, 419 ), Cons( Pair( Cores, 8 ), Cons( Pair( Memory, 1500 ), Cons( Pair( Speed, 31 ), Nil ) ) ) )) ));
    this.addInstanceDescription(Pair( "c4_2xlarge_us2", map(Cons( Pair( CostPerInterval, 419 ), Cons( Pair( Cores, 8 ), Cons( Pair( Memory, 1500 ), Cons( Pair( Speed, 31 ), Nil ) ) ) )) ));
    this.addInstanceDescription(Pair( "m4_large_us1", map(Cons( Pair( CostPerInterval, 120 ), Cons( Pair( Cores, 2 ), Cons( Pair( Memory, 800 ), Cons( Pair( Speed, 6 ), Nil ) ) ) )) ));
    this.addInstanceDescription(Pair( "c4_xlarge_eu", map(Cons( Pair( CostPerInterval, 209 ), Cons( Pair( Cores, 4 ), Cons( Pair( Memory, 750 ), Cons( Pair( Speed, 16 ), Nil ) ) ) )) ));
    this.addInstanceDescription(Pair( "c4_xlarge_us1", map(Cons( Pair( CostPerInterval, 209 ), Cons( Pair( Cores, 4 ), Cons( Pair( Memory, 750 ), Cons( Pair( Speed, 16 ), Nil ) ) ) )) ));
    this.addInstanceDescription(Pair( "c4_xlarge_us2", map(Cons( Pair( CostPerInterval, 209 ), Cons( Pair( Cores, 4 ), Cons( Pair( Memory, 750 ), Cons( Pair( Speed, 16 ), Nil ) ) ) )) ));
    this.addInstanceDescription(Pair( "m4_xlarge_us2", map(Cons( Pair( CostPerInterval, 239 ), Cons( Pair( Cores, 4 ), Cons( Pair( Memory, 1600 ), Cons( Pair( Speed, 13 ), Nil ) ) ) )) ));
    this.addInstanceDescription(Pair( "m4_xlarge_us1", map(Cons( Pair( CostPerInterval, 239 ), Cons( Pair( Cores, 4 ), Cons( Pair( Memory, 1600 ), Cons( Pair( Speed, 13 ), Nil ) ) ) )) ));
  }

}

def Bool contains_<A>(List<A> xs, A y) = case xs {
                Nil => False;
                Cons(x_,xs_) => x_ == y || contains_(xs_,y);
    };